<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8"/>
		<title>WebGL Example</title>

		<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
			in vec4 vPosition;
			// TODO: Nimm die Normalen als Attribut entgegen
			in vec4 vNormal;

			uniform mat4 uModelMatrix;
			uniform mat4 uViewMatrix;
			uniform mat4 uProjectionMatrix;

			// TODO: Nimm die Position der Lichtquelle als Uniform-Variable entgegen
			uniform vec3 lightPosition;

			// TODO: Nimm alle Koeffizienten und Intensitäten, sowie den Exponenten als Uniform-Variablen entgegen
			uniform vec3 Ia;
			uniform vec3 Id;
			uniform vec3 Is;
			uniform vec3 ka;
			uniform vec3 kd;
			uniform vec3 ks;
		  uniform float specExp;

			// TODO: Definiere alle Konstanten c_1, c_2, c_3
			out vec3 vfColor;

			const float c_1 = 1.0;
			const float c_2 = 0.0005;
			const float c_3 = 0.000003;
			const int n = 4;

			void main()
			{
				mat4 modelViewMatrix = uViewMatrix * uModelMatrix;

				// TODO: Berechne die Normalenmatrix
				mat4 normalMatrix = transpose(inverse(modelViewMatrix));

				// TODO: Rechne alle übergebenen Koordinaten (Lichtposition, Normalen) in das Kamerakoordinatensystem um
				// Position wird in Welt- und dann in Kamerakoordinatensystem umgerechnet
				vec4 position = modelViewMatrix * vPosition;
				// Da die Lichtquelle im Weltkoordinatensystem definiert war,
				// muss sie hier in das Kamerakoordinatensystem umgerechnet werden
				vec4 light = uViewMatrix * vec4(lightPosition, 1.0);
				vec4 normal = normalMatrix * vNormal;
				// Kamera steht im Ursprung ihres eigenen Koordinatensystems und schaut in negative Z-Richtung
				// alternativ: vec4 camera = -position, da die position bereits im Kamerakoordinatensystem ist
				vec4 camera = vec4(0.0, 0.0, 0.0, 1.0);

				// TODO: Berechne und normalisiere die Vektoren L, N, R und V
				// Tipp aus den References: For a given incident vector I and surface normal N reflect returns the reflection direction calculated as I - 2.0 * dot(N, I) * N.
				// I ist in diesem Fall der normalisierte Einheitsvektor -L (Siehe Diskussion 7)
				vec3 N = normalize(normal.xyz);
				vec3 L = normalize(light.xyz - position.xyz);
				vec3 R = reflect(-L, N);
				vec3 V = normalize(camera.xyz - position.xyz);

				vec3 ambientIntensity = Ia * ka;
				vec3 diffuseIntensity = Id * kd * max(0.0, dot(N, L));
				vec3 specularIntensity = Is * ks * pow(max(0.0, dot(V, R)), specExp);

				// TODO: Berechne die Distanz d, sowie f_{att}
				float d = length(light.xyz - position.xyz);
				float f_att = min(1.0 / (c_1 + c_2 * d + c_3 * d * d), 1.0);

				vfColor = ambientIntensity + f_att * (diffuseIntensity + specularIntensity);
				gl_Position = uProjectionMatrix * position;
			}
		</script>
		<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
			precision mediump float;

			in vec3 vfColor;
			out vec4 fColor;

			void main()
			{
				fColor = vec4(vfColor, 1.0);
			}
		</script>
		<script type="text/javascript" src="common/initShaders.js"></script>
		<script type="text/javascript" src="common/gl-matrix.js"></script>
		<script type="text/javascript" src="common/objects3D.js"></script>
	</head>
	<body>
		<h1>Lorem Ipsum</h1>

		<canvas id="gl-canvas" width="1024" height="512">
			If you see this, your browser doesn't support WebGL.
		</canvas>

		<script src="main.js" type="text/javascript"></script>
	</body>
</html>
